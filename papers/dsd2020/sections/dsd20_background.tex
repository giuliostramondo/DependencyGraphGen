\section{Background}
\label{sec:bg}
A \textit{spatial programming} architecture implements an algorithm using a set of \textit{Processing Elements (PEs)} connected through an on-chip network. The operations performed by the algorithm are mapped on the PEs, which compute in a fine-grained pipeline fashion. There are different kinds of spatial architecture\cite{parashar2014efficient}, one possible classification is shown in Figure \ref{fig:spatial_class}. Spatially programmed architectecture in which the PEs implement basic logic operations, and can be programmed at design-time are \textit{Design-Time Progammable}. To change the functionality of a Design-Time Programmable architecture, the architecture design needs to be modified and re-synthesized. \textit{Compile-Time Programmable} spatial architectures are instead programmable at instruction level and their PEs implement simplified ALUs. The functionality of a \textit{Compile-Time Programmable} spatial accelerator can change by modifying the sequence of instructions it executes.
The advantage of using \textit{Compile-Time} over \textit{Design-time} programmable architectures lies in their higher computational density of the former, which results in an higher operational frequency and lower power consumption.
The \textit{Compile-Time Programmable} class is itself composed of architecture having Centralized Control, where a single control unit manages all the PEs, and Distributed Control, where each PE has a built-in control mechanism. Intuitively, an architecture with distributed control is more scalable and has a simpler interconnection network.

$\mu$-Genie generates distributed control spatial architectures optimized for input applications.
\begin{figure}
  \centering
  \resizebox{0.7\columnwidth}{!}{%
    \begin{tikzpicture}[
      % For compatability with PGF CVS add the absolute option:
      absolute
      ]
      \begin{scope}[xshift=-7.5cm,yshift=-5cm,very thick,
        node distance=2cm,on grid,>=stealth',
        block/.style={rectangle,draw,font=\sffamily,fill=cyan!20,text width=2cm,text centered}]

        \node[block, text width=2.5cm] (spatial_acc) {Spatially Programmed Accelerators};
        \node[below=of spatial_acc]  (dummy1){};
        \node[block, left=of dummy1,text width=2.5cm] (logic_grain) {Design-Time Programmable};
        % \node[below=of logic_grain,yshift=35pt] (fpga) {FPGAs};
        \node[block, right=of dummy1, text width=2.5cm] (inst) {Compile-Time Programmable};
        \node[below=of inst] (dummy2){};
        \node[block, left=of dummy2] (cent_ctrl) {Centralized Control};
        \node[block, right=of dummy2] (dist_ctrl) {Distributed Control};
        \draw[-] (spatial_acc) -- (logic_grain);
        \draw[-] (spatial_acc) -- (inst);
        \draw[-] (inst) -- (cent_ctrl);
        \draw[-] (inst) -- (dist_ctrl);
      \end{scope}

    \end{tikzpicture}
  }
  \caption{Spatial Architectures classification \cite{parashar2014efficient}.} \label{fig:spatial_class}
\end{figure}

%This section will contain the relevant background. Consider the following items:
%\begin{itemize}
%\item Taxonomy of accelerators
%\item Non-Volatile Memories
%\item Memory wall
%\item Static Data-Dependency Analysis
%\item System Under Analysis
%\end{itemize}
